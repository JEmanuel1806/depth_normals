#version 440

layout(local_size_x = 8, local_size_y = 8) in;

layout(r32i, binding = 0) uniform iimage2D idTex;
layout(rgba32f, binding = 1) uniform image2D normalTex;
uniform sampler2D depthTex;

uniform ivec2 screenSize;
uniform mat4 proj;
uniform mat4 invProj;
uniform mat4 view;

uniform mat4 invView;

vec3 getPos(ivec2 fragCoord, float depth) {
        
    vec2 ndc = (vec2(fragCoord) / screenSize) * 2.0 - 1.0;
    float ndcDepth = depth * 2.0 - 1.0; // - 1 to 1
    
    vec4 clipSpace = vec4(ndc, ndcDepth, 1.0);
    vec4 viewSpace = invProj * clipSpace;
    viewSpace /= viewSpace.w;

    vec4 worldSpace = invView * viewSpace;
    return worldSpace.xyz;
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    if (pixelPos.x >= screenSize.x || pixelPos.y >= screenSize.y)
        return;

    int myID = imageLoad(idTex, pixelPos).r;
    float myDepth = texelFetch(depthTex, pixelPos, 0).r;
    if (myID < -1) 
        return;

    vec3 l, r, u, d;
    float debugL, debugR, debugU, debugD = -1;

    bool foundL = false, foundR = false, foundU = false, foundD = false;

    for (int offset = 1; offset < 50; ++offset) {
        // Left
        if (!foundL) {
            ivec2 neighborL = pixelPos + ivec2(-offset, 0);
            if (neighborL.x >= 0) {
                int idL = imageLoad(idTex, neighborL).r;
                float dL = texelFetch(depthTex, neighborL, 0).r;
                if (idL > -1 && idL != myID) {
                    l = getPos(neighborL, dL);
                    debugL = dL;
                    foundL = true;
                }
            }
        }

        // Right
        if (!foundR) {
            ivec2 neighborR = pixelPos + ivec2(offset, 0);
            if (neighborR.x < screenSize.x) {
                int idR = imageLoad(idTex, neighborR).r;
                float dR = texelFetch(depthTex, neighborR, 0).r;
                if (idR > -1 && idR != myID) {
                    r = getPos(neighborR, dR);
                    debugR = dR;
                    foundR = true;
                }
            }
        }

        // Up
        if (!foundU) {
            ivec2 neighborU = pixelPos + ivec2(0, offset);
            if (neighborU.y < screenSize.y) {
                int idU = imageLoad(idTex, neighborU).r;
                float dU = texelFetch(depthTex, neighborU, 0).r;
                if (idU > -1 && idU != myID) {
                    u = getPos(neighborU, dU);
                    debugU = dU;
                    foundU = true;
                }
            }
        }

        // Down
        if (!foundD) {
            ivec2 neighborD = pixelPos + ivec2(0, -offset);
            if (neighborD.y >= 0) {
                int idD = imageLoad(idTex, neighborD).r;
                float dD = texelFetch(depthTex, neighborD, 0).r;
                if (idD > -1 && idD != myID) {
                    d = getPos(neighborD, dD);
                    debugD = dD;
                    foundD = true;
                }
            }
        }

        if (foundL && foundR && foundU && foundD)
            break;
    }

    if (foundL && foundR && foundU && foundD) {
        vec3 dpdx = r - l;
        vec3 dpdy = d - u;
        
        // Debug to check if crossVec broken
        vec3 crossVec = cross(dpdx, dpdy);
        vec3 normal = normalize(crossVec);

        if (normal.z > 0)
            normal *= -1;

         if (length(normal) < 1e-5) // check if normal is 0
            imageStore(normalTex, pixelPos, vec4(1.0, 0.0, 0.0, 1.0)); //red
        else
            imageStore(normalTex, pixelPos, vec4(debugL,debugR,debugD, 1.0));
    } else {
        imageStore(normalTex, pixelPos, vec4(1.0, 0.0, 1.0, 1.0));
    }
}
