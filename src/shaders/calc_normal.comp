#version 450 core 
#extension GL_NV_shader_atomic_float : enable
layout(local_size_x = 8, local_size_y = 8) in;

uniform sampler2D  ref_depth;
uniform isampler2D ref_id;

uniform sampler2D  splat_depth;
uniform isampler2D splat_id;

uniform ivec2 screenSize;
uniform mat4 invProj;
uniform mat4 view;
uniform mat4 proj;
uniform mat4 invView;
uniform float maxID;

uniform float zFar;
uniform float zNear;

struct NormalBuffer{
    vec3 normal;
    int counter;
};

const ivec2 offsets[25] = ivec2[25](
    ivec2(-2,  2), ivec2(-1,  2), ivec2(0,  2), ivec2(1,  2), ivec2(2,  2),
    ivec2(-2,  1), ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1), ivec2(2,  1),
    ivec2(-2,  0), ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0), ivec2(2,  0),
    ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1),
    ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2)
);

vec3 kernelPositions[25];

layout(std430, binding = 0) buffer NormalSumBuffer { NormalBuffer normalBuffer[]; };


float delinearize_depth(float z_buffer_depth, float zNear, float zFar) {
    float z = z_buffer_depth * 2.0 - 1.0;
    return (2.0 * zNear * zFar) / (zFar + zNear - z * (zFar - zNear));
}

vec3 getPos(ivec2 fragCoord, float depth) {
    vec2 ndc = ((vec2(fragCoord) + 0.5) / vec2(screenSize)) * 2.0 - 1.0;
    float ndcDepth = depth * 2.0 - 1.0;
    vec4 clipSpace = vec4(ndc, ndcDepth, 1.0);
    vec4 viewSpace = invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}

void main() {
	// get depth and ID from splat texture
    ivec2 currentPixelPos = ivec2(gl_GlobalInvocationID.xy);
    float currentPixelDepth = texelFetch(splat_depth, currentPixelPos, 0).r;
    int currentPixelID = texelFetch(splat_id, currentPixelPos,0).r;

    if (currentPixelPos.x <= 0 || currentPixelPos.y <= 0 || 
    currentPixelPos.x >= screenSize.x - 1 || currentPixelPos.y >= screenSize.y - 1) 
    return;
    

    // reconstruct points
    vec3 reconstructedPoint = getPos(currentPixelPos, currentPixelDepth);

    vec3 normalSum = vec3(0);

    // 5x5 KERNEL
    for (int i = 0; i < 25; ++i)
    {
        ivec2 kernelCoord = currentPixelPos + offsets[i];
        float kernelDepth = texelFetch(splat_depth, kernelCoord,0).r;
        if(abs(kernelDepth - currentPixelDepth) > 1){
            kernelPositions[i] = vec3(0);
            continue;
        }
        kernelPositions[i] = getPos(kernelCoord, kernelDepth);

    }

    vec3 leftNext  = kernelPositions[11];  // -1, 0
    vec3 leftFar   = kernelPositions[10];  // -2, 0
    vec3 rightNext = kernelPositions[13];  // +1, 0
    vec3 rightFar  = kernelPositions[14];  // +2, 0
    
    vec3 upNext    = kernelPositions[7];   // 0, -1
    vec3 upFar     = kernelPositions[2];   // 0, -2
    vec3 downNext  = kernelPositions[17];  // 0, +1
    vec3 downFar   = kernelPositions[22];  // 0, +2
    
    vec3 upLeft    = kernelPositions[6];   // -1, -1
    vec3 upRight   = kernelPositions[8];   // +1, -1
    vec3 downLeft  = kernelPositions[16];  // -1, +1
    vec3 downRight = kernelPositions[18];  // +1, +1
    
    vec3 upLeftFar    = kernelPositions[0];   // -2, -2
    vec3 upRightFar   = kernelPositions[4];   // +2, -2
    vec3 downLeftFar  = kernelPositions[20];  // -2, +2
    vec3 downRightFar = kernelPositions[24];  // +2, +2
        
    if (length(rightNext) > 1e-6 && length(leftNext) > 1e-6 &&
        length(upNext)    > 1e-6 && length(downNext) > 1e-6) {
        normalSum += normalize(cross(rightNext - leftNext, upNext - downNext));
    }
    
    if (length(downLeft)  > 1e-6 && length(upRight)   > 1e-6 &&
        length(downRight) > 1e-6 && length(upLeft)    > 1e-6) {
        normalSum += normalize(cross(downLeft - upRight, downRight - upLeft)); // diagonal
    }
    
    if (length(rightFar) > 1e-6 && length(leftFar) > 1e-6 &&
        length(upFar)    > 1e-6 && length(downFar) > 1e-6) {
        normalSum += normalize(cross(rightFar - leftFar, upFar - downFar));
    }
    
    if (length(downLeftFar)  > 1e-6 && length(upRightFar)   > 1e-6 &&
        length(downRightFar) > 1e-6 && length(upLeftFar)    > 1e-6) {
        normalSum += normalize(cross(downLeftFar - upRightFar, downRightFar - upLeftFar)); // diagonal
    }


    // normal calc 
    //vec3 normal = cross(dFdx(reconstructedPoint), dFdy(reconstructedPoint));
    
    vec3 normal = normalize(mat3(invView) * normalSum);

    atomicAdd(normalBuffer[currentPixelID].normal.x, normal.x);
    atomicAdd(normalBuffer[currentPixelID].normal.y, normal.y);
    atomicAdd(normalBuffer[currentPixelID].normal.z, normal.z);
    atomicAdd(normalBuffer[currentPixelID].counter, 1);

    /* debug 
    float delinearizedDepth = delinearize_depth(currentPixelDepth, zNear, zFar); 
    vec3 normal = vec3(delinearizedDepth, currentPixelID, 0);
    points[currentPixelID].normal = normal;
    */
}