#version 440 core

layout(local_size_x = 8, local_size_y = 8) in;

uniform sampler2D ref_depth;
uniform isampler2D ref_id;

uniform sampler2D splat_depth;
uniform isampler2D splat_id;

uniform ivec2 screenSize;
uniform mat4 proj;
uniform mat4 invProj;
uniform mat4 view;

uniform float zNear;
uniform float zFar;
uniform float maxID;

uniform mat4 invView;

const ivec2 OFFS[24] = ivec2[24](
  ivec2(0,0), 
  ivec2(1,0), ivec2(-1,0), ivec2(0,1), ivec2(0,-1),
  ivec2(2,0), ivec2(-2,0), ivec2(0,2), ivec2(0,-2),
  ivec2(1,1), ivec2(1,-1), ivec2(-1,1), ivec2(-1,-1),
  ivec2(2,1), ivec2(2,-1), ivec2(-2,1), ivec2(-2,-1),
  ivec2(1,2), ivec2(1,-2), ivec2(-1,2), ivec2(-1,-2),
  ivec2(2,2), ivec2(-2,2), ivec2(2,-2) 
);

struct Point {
    int  pointID; 

    vec3 position; 
    float _padA;

    vec3 color;   
    float _padB;
    
    vec3 normal;   
    float _padC;     
};

layout(std430, binding = 0) buffer PointBuffer {
    Point points[];
};

// reconstruct position
vec3 getPos(ivec2 fragCoord, float depth) {
    
    vec2 ndc = ((vec2(fragCoord) + 0.5) / vec2(screenSize)) * 2.0 - 1.0;
    float ndcDepth = depth * 2.0 - 1.0; 
    
    vec4 clipSpace = vec4(ndc, ndcDepth, 1.0);
    vec4 viewSpace = invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}

void main() {

    // read pixel and get id and depth
    ivec2 currentPos = ivec2(gl_GlobalInvocationID.xy);
    int currentID = texelFetch(ref_id, currentPos, 0).r;
    if (currentID < 0) return;
    float currentDepth = texelFetch(ref_depth, currentPos, 0).r;
    
    vec3 reconstructedPoint = getPos(currentPos, currentDepth);

    vec3 sum = vec3(0.0);
    int count = 0;

    for (int i = 0; i < OFFS.length(); ++i) {
        ivec2 offsetPos = currentPos + OFFS[i];
        if (offsetPos.x < 0 || offsetPos.y < 0 || offsetPos.x >= screenSize.x || offsetPos.y >= screenSize.y)
            continue;

        int offsetID = texelFetch(splat_id, offsetPos, 0).r;
        if (offsetID < 0 || offsetID == currentID) 
            continue;

        
        vec3 neighborPoint = points[offsetID].position;

        if (distance(reconstructedPoint, neighborPoint) > 1.0) continue;

        sum += normalize(neighborPoint - reconstructedPoint);
        count++;
    }

    if (count > 0) {
        //vec3 normal = normalize(-sum / float(count));
        points[currentID].normal = vec3(0.25,0.25,0.25);
    }
    else{
        points[currentID].normal = vec3(0,-0.5,-0.5);
    } 
}
