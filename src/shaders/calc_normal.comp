#version 450 core 
#extension GL_NV_shader_atomic_float : enable
layout(local_size_x = 8, local_size_y = 8) in;

uniform sampler2D  ref_depth;
uniform isampler2D ref_id;

uniform sampler2D  splat_depth;
uniform isampler2D splat_id;

uniform ivec2 screenSize;
uniform mat4 invProj;
uniform mat4 view;
uniform mat4 proj;
uniform mat4 invView;
uniform float maxID;

uniform float zFar;
uniform float zNear;

struct NormalBuffer{
    vec3 normal;
    int counter;
};

layout(std430, binding = 0) buffer NormalSumBuffer { NormalBuffer normalBuffer[]; };



float delinearize_depth(float z_buffer_depth, float zNear, float zFar) {
    float z = z_buffer_depth * 2.0 - 1.0;
    return (2.0 * zNear * zFar) / (zFar + zNear - z * (zFar - zNear));
}

vec3 getPos(ivec2 fragCoord, float depth) {
    vec2 ndc = ((vec2(fragCoord) + 0.5) / vec2(screenSize)) * 2.0 - 1.0;
    float ndcDepth = depth * 2.0 - 1.0;
    vec4 clipSpace = vec4(ndc, ndcDepth, 1.0);
    vec4 viewSpace = invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}

void main() {
	// get depth and ID from splat texture
    ivec2 currentPixelPos = ivec2(gl_GlobalInvocationID.xy);
    float currentPixelDepth = texelFetch(splat_depth, currentPixelPos, 0).r;
    int currentPixelID = texelFetch(splat_id, currentPixelPos,0).r;

    if (currentPixelPos.x <= 0 || currentPixelPos.y <= 0 || 
    currentPixelPos.x >= screenSize.x - 1 || currentPixelPos.y >= screenSize.y - 1) 
    return;
    

    // reconstruct points
    vec3 reconstructedPoint = getPos(currentPixelPos, currentPixelDepth);

    // find and reconstruct neighbors (CROSS)
    ivec2 leftPos = currentPixelPos + ivec2(-1, 0);
    ivec2 rightPos = currentPixelPos + ivec2(1, 0);
    ivec2 upPos = currentPixelPos + ivec2(0, 1);
    ivec2 downPos = currentPixelPos + ivec2(0, -1);
    
    float leftPixelDepth = texelFetch(splat_depth, leftPos, 0).r;
    float rightPixelDepth = texelFetch(splat_depth, rightPos, 0).r;
    float upPixelDepth = texelFetch(splat_depth, upPos, 0).r;
    float downPixelDepth = texelFetch(splat_depth, downPos, 0).r;
    
    vec3 leftReconstructedPoint = getPos(leftPos, leftPixelDepth);
    vec3 rightReconstructedPoint = getPos(rightPos, rightPixelDepth);
    vec3 upReconstructedPoint = getPos(upPos, upPixelDepth);
    vec3 downReconstructedPoint = getPos(downPos, downPixelDepth);
    
    // gradient calc
    vec3 dpdx = rightReconstructedPoint-leftReconstructedPoint;
    vec3 dpdy = upReconstructedPoint-downReconstructedPoint;

    // normal calc 
    //vec3 normal = cross(dFdx(reconstructedPoint), dFdy(reconstructedPoint));
    
    vec3 normal = normalize(mat3(invView) * normalize(cross(dpdx,dpdy)));

    atomicAdd(normalBuffer[currentPixelID].normal.x, normal.x);
    atomicAdd(normalBuffer[currentPixelID].normal.y, normal.y);
    atomicAdd(normalBuffer[currentPixelID].normal.z, normal.z);
    atomicAdd(normalBuffer[currentPixelID].counter, 1);

    /* debug 
    float delinearizedDepth = delinearize_depth(currentPixelDepth, zNear, zFar); 
    vec3 normal = vec3(delinearizedDepth, currentPixelID, 0);
    points[currentPixelID].normal = normal;
    */
}