#version 440 core
layout(local_size_x = 8, local_size_y = 8) in;

uniform sampler2D  ref_depth;
uniform isampler2D ref_id;

uniform sampler2D  splat_depth;
uniform isampler2D splat_id;

uniform ivec2 screenSize;
uniform mat4 invProj;
uniform mat4 view;
uniform mat4 proj;
uniform mat4 invView;
uniform float maxID;

uniform float zFar;
uniform float zNear;

int radius = 8;

struct Point {
    int  pointID;
    vec3 position; float _padA;
    vec3 color;    float _padB;
    vec3 normal;   float _padC;
};

vec3 top = vec3(0);
vec3 down = vec3(0);
vec3 left = vec3(0);
vec3 right = vec3(0);

bool haveTop=false;
bool haveDown=false;
bool haveLeft=false;
bool haveRight=false;

layout(std430, binding = 0) buffer PointBuffer { Point points[]; };

vec3 getPos(ivec2 fragCoord, float depth) {
    vec2 ndc = ((vec2(fragCoord) + 0.5) / vec2(screenSize)) * 2.0 - 1.0;
    float ndcDepth = depth * 2.0 - 1.0;
    vec4 clipSpace = vec4(ndc, ndcDepth, 1.0);
    vec4 viewSpace = invProj * clipSpace;
    viewSpace /= viewSpace.w;
    return viewSpace.xyz;
}

vec2 worldToScreenSpace(vec3 positionWorld) {
    vec4 clipSpace = proj * view * vec4(positionWorld, 1.0);
    vec3 ndc = clipSpace.xyz / clipSpace.w;
    vec2 screenSpace = (ndc.xy * 0.5 + 0.5) * vec2(screenSize);
    return screenSpace;
}

// calculate 3D Position distance and add a weight depending on view space distance
float calculateRangeWeight(vec3 neighborPoint, vec3 currentPoint, float sigma_r) {
    float dist = distance(currentPoint, neighborPoint); 
    return exp(-(dist * dist) / (2.0 * sigma_r * sigma_r));
}

// calculate 2D Screen Position distance and add a weight depending on pixels
float calculateSpatialWeight(vec2 neighborPoint, vec2 currentPoint, float sigma_s){
    float dist = distance(currentPoint, neighborPoint); 
    return exp(-(dist * dist) / (2.0 * sigma_s * sigma_s));
}

void main() {
    ivec2 currentPos = ivec2(gl_GlobalInvocationID.xy);
    int currentID = texelFetch(ref_id, currentPos, 0).r;
    if (currentID < 0 || currentID >= int(maxID)) return;

    float currentDepth = texelFetch(ref_depth, currentPos, 0).r;
    vec3 reconstructedPoint = getPos(currentPos, currentDepth);
    float zc = abs(reconstructedPoint.z);
    float tau_z = 0.01 * zc; 

    vec3 sumX = vec3(0.0);
    vec3 sumY = vec3(0.0);
    float wX = 0.0;
    float wY = 0.0;

    for (int i = -radius; i <= radius; ++i) {
        for (int j = -radius; j <= radius; ++j) {
            if (i==0 && j==0) continue;

            ivec2 offsetPos = currentPos + ivec2(i, j);
            if (offsetPos.x < 0 || offsetPos.y < 0 ||
                offsetPos.x >= screenSize.x || offsetPos.y >= screenSize.y)
                continue;

            int offsetID = texelFetch(splat_id, offsetPos, 0).r;
            if (offsetID < 0 || offsetID >= int(maxID))
                continue;

            // reconstruct neighbor position and depth with its ID value
            vec3 neighborPos3D = points[offsetID].position;
            ivec2 neighborPos = ivec2(round(worldToScreenSpace(neighborPos3D)));

            if (neighborPos.x < 0 || neighborPos.y < 0 ||
                neighborPos.x >= screenSize.x || neighborPos.y >= screenSize.y)
                continue;

            float neighborDepth = texelFetch(ref_depth, neighborPos, 0).r;

            float zn = abs(getPos(neighborPos, neighborDepth).z);
            if (abs(zc - zn) > tau_z) continue;

            vec3 reconstructedNeighbor = getPos(neighborPos, neighborDepth);

            // weight calculation
            float rangeWeight = calculateRangeWeight(reconstructedNeighbor, reconstructedPoint, 0.03 * abs(reconstructedPoint.z));
            float spatialWeight = calculateSpatialWeight(neighborPos, currentPos, 1.5);
            float neighborWeight = rangeWeight * spatialWeight;

            vec3 dP = reconstructedNeighbor - reconstructedPoint;

            if (i != 0) {
                sumX += neighborWeight * dP * float(i);
                wX   += neighborWeight * abs(float(i));
            }
            if (j != 0) {
                sumY += neighborWeight * dP * float(j);
                wY   += neighborWeight * abs(float(j));
            }

            // (old L/R/T/B logic kept but no longer needed)
            if (abs(i) >= abs(j)) { // horizontal
                if (i < 0 && !haveLeft)  { left  = reconstructedNeighbor; haveLeft  = true; }
                if (i > 0 && !haveRight) { right = reconstructedNeighbor; haveRight = true; }
            } else { // vertical
                if (j < 0 && !haveDown) { down = reconstructedNeighbor; haveDown = true; }
                if (j > 0 && !haveTop)  { top  = reconstructedNeighbor; haveTop  = true; }
            }

            // early exit when all 4 are set (will rarely trigger now)
            if (haveLeft && haveRight && haveTop && haveDown) break;
        }
        if (haveLeft && haveRight && haveTop && haveDown) break;
    }

    vec3 normal = vec3(0.0);
    vec3 dPdx = vec3(0.0);
    vec3 dPdy = vec3(0.0);

    if (wX > 0.0) dPdx = sumX / wX;
    if (wY > 0.0) dPdy = sumY / wY;

    if (length(dPdx) > 1e-6 && length(dPdy) > 1e-6) {
        normal = normalize(cross(dPdx, dPdy));
        if (normal.z < 0.0) normal = -normal;
    }

    points[currentID].normal = normal;
}
