#version 450 core
layout(local_size_x = 8, local_size_y = 8) in;

uniform isampler2D ref_id;

struct Point {
    int  pointID;
    vec3 position; float _padA;
    vec3 color;    float _padB;
    vec3 normal;   float _padC;
};

struct NormalBuffer{
    vec3 normal;
    int counter;
};

vec3 invisible = vec3(0.141f, 0.149f, 0.192f);

layout(std430, binding = 0) buffer NormalSumBuffer { NormalBuffer normalBuffer[]; };
layout(std430, binding = 1) buffer PointGTBuffer { Point pointsGT[]; };
layout(std430, binding = 2) buffer PointBuffer { Point points[]; };



void main(){
    ivec2 currentPos = ivec2(gl_GlobalInvocationID.xy);
    int currentID = texelFetch(ref_id, currentPos, 0).r;
    
    if (currentID >= 0) {   
      points[currentID].normal = normalize(vec3(normalBuffer[currentID].normal/normalBuffer[currentID].counter));
    

        float d = clamp(dot(points[currentID].normal, pointsGT[currentID].normal), -1.0, 1.0); 
        float theta = degrees(acos(d));
        //if (d < 0.0) { d = -d; }  

        if(theta >= 0.01 && theta <= 10.0){
            // points[currentID].color = vec3(0, 1, 0);
            points[currentID].color = invisible;
        }
        else if(theta >= 0.01 && theta <= 30.0){
            points[currentID].color = vec3(1,1,0);
        }
        else if(theta > 30.0 && theta <= 180) {
            points[currentID].color = vec3(1,0,0);
        }
        else{
            points[currentID].color = invisible; //occluded or errors
        }
    }
}